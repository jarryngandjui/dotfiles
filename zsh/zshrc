# === DOTFILES ZSH CONFIGURATION START - DO NOT EDIT MANUALLY ===

# Environment Variables
# =====================

# Executables
export PATH="/opt/homebrew/bin:$PATH"
export PATH="/opt/homebrew/sbin:$PATH"
export PATH="/usr/local/bin:$PATH"
export PATH="/usr/bin:$PATH"
export PATH="/usr/sbin:$PATH"
export PATH="/bin:$PATH"
export PATH="/sbin:$PATH"
export PATH="/System/Cryptexes/App/usr/bin:$PATH"
export PATH="$HOME/.local/bin:$PATH"
export PATH="$HOME/Library/Application Support/JetBrains/Toolbox/scripts:$PATH"
export PATH="$HOME/Library/Python/3.9/bin:$PATH" # Add python path for nvim pylsp
export PATH="/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:$PATH"
export PATH="/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:$PATH"
export PATH="/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:$PATH"

# Quick access files and directories
export PROJECTS=$HOME/Projects
export DOTFILES=$HOME/dotfiles
export WEBSITE=$PROJECTS/website
export NOTES="$HOME/Library/Mobile\ Documents/iCloud~md~obsidian/Documents/Second\ brain"
export CONFIG=$DOTFILES
export ALACRITTYCONFIG=$CONFIG/alacritty/alacritty.toml
export NVIMCONF=$CONFIG/nvim/
export NVIMINIT=$CONFIG/nvim/init.lua
export NVIMLOCK=$CONFIG/nvim/lazy-lock.json

export STARSHIPCONF=$CONFIG/starship/starship.toml
export TMUXCONF=$CONFIG/tmux/tmux.conf
export ZSHRC=$CONFIG/zsh/zshrc
export ZSHPROFILE=$CONFIG/zsh/zprofile

# Node version manager directory
export N_PREFIX=$HOME/n

# Vi mode
# =======
set -o vi

# History substring search
# ========================
# Enable history search with up/down arrows based on what's already typed

# Configuration variables
HISTORY_SUBSTRING_SEARCH_HIGHLIGHT_FOUND='bg=blue,fg=white,bold'
HISTORY_SUBSTRING_SEARCH_HIGHLIGHT_NOT_FOUND='bg=red,fg=white,bold'
HISTORY_SUBSTRING_SEARCH_GLOBBING_FLAGS='i'
HISTORY_SUBSTRING_SEARCH_ENSURE_UNIQUE='true'
HISTORY_SUBSTRING_SEARCH_FUZZY=''
HISTORY_SUBSTRING_SEARCH_PREFIXED=''

# Load the plugin
source $(brew --prefix)/share/zsh-history-substring-search/zsh-history-substring-search.zsh

# Key bindings for emacs mode
bindkey '^[[A' history-substring-search-up    # Up arrow
bindkey '^[[B' history-substring-search-down  # Down arrow

# Key bindings for vi mode
bindkey -M vicmd 'k' history-substring-search-up
bindkey -M vicmd 'j' history-substring-search-down

# Additional key bindings for better navigation
# These provide fallback key bindings for different terminal types

# Auto cd
# =======
setopt AUTO_CD

# Zsh completion system
# ====================
autoload -Uz compinit
compinit

# Aliases
# =======

# Editor
alias vim="nvim"

# Python
alias python='eval $(which python3)'
alias pip='eval $(which pip3)'
alias activate='source ./venv/bin/activate'

# Quick navigation
alias projects="cd $PROJECTS"
alias brain="cd $NOTES"
alias dotfiles="cd $DOTFILES"
alias website="cd $WEBSITE"

# Configuration editing
alias alacrittyconfig="vim $ALACRITTYCONFIG"
alias nvimconf="vim $NVIMCONF"
alias starshipconf="vim $STARSHIPCONF"
alias tmuxconf="vim $TMUXCONF"
alias zshrc="vim $ZSHRC"
alias zprofile="vim $ZSHPROFILE"

# Dotfiles management
alias dot="make -C $DOTFILES"

# Dotfiles autocompletion
_dot_completion() {
    local -a make_targets
    local makefile_path="$DOTFILES/Makefile"
    
    # Extract targets from Makefile dynamically
    if [ -f "$makefile_path" ]; then
        # Get all .PHONY targets and their descriptions from help target
        make_targets=($(cd "$DOTFILES" && make help 2>/dev/null | grep -E '^  [a-zA-Z-]+' | sed 's/^  \([a-zA-Z-]*\)[[:space:]]*-[[:space:]]*\(.*\)/\1:\2/'))
    else
        # Fallback if Makefile not found
        make_targets=('help:Show available targets')
    fi
    
    _describe 'dot targets' make_targets
}

compdef _dot_completion dot

# Git
# ===

# Git helper functions
git_main_branch() {
  command git rev-parse --git-dir &>/dev/null || return
  local ref
  for ref in refs/{heads,remotes/{origin,upstream}}/{main,trunk,mainline,default}; do
    if command git show-ref -q --verify $ref; then
      echo ${ref:t}
      return
    fi
  done
  echo master
}

git_develop_branch() {
  command git rev-parse --git-dir &>/dev/null || return
  local ref
  for ref in refs/{heads,remotes/{origin,upstream}}/{dev,devel,development}; do
    if command git show-ref -q --verify $ref; then
      echo ${ref:t}
      return
    fi
  done
  echo develop
}

git_current_branch() {
  command git rev-parse --abbrev-ref HEAD 2>/dev/null
}

current_branch() {
  git_current_branch
}

# Git add aliases
alias ga="git add"
alias gat="ga -u"  # git add -u : updates existing files that are tracked and does not add new ones

# Git branch aliases
alias gb="git branch"
alias gbd="git branch -d"

# Git checkout aliases
alias gcm="git checkout $(git_main_branch)"
alias gcd="git checkout $(git_develop_branch)"
alias gco="git checkout"

# Git cherry-pick aliases
alias gcp="git cherry-pick"
alias gcpa="git cherry-pick --abort"
alias gcpc="git cherry-pick --continue"

# Git commit aliases
alias gcmsg="git commit -m"

# Git diff aliases
alias gd="git diff"
alias gdca="git diff --cached"
alias gdup="git diff @{upstream}"

# Git fetch aliases
alias gf="git fetch"
alias gfo="git fetch origin"

# Git help aliases
alias ghh="git help"

# Git merge aliases
alias gm="git merge"
alias gma="git merge --abort"

# Git pull aliases
alias gl="git pull"
alias glr="git pull --rebase"

# Git push aliases
alias gp="git push"
alias gpd="git push --dry-run"
alias gpf="git push --force"
alias gpfo="git push --force origin $(current_branch)"
alias gpsup='git push --set-upstream origin $(git_current_branch)'

# Git rebase aliases
alias grb="git rebase"
alias grba="git rebase --abort"
alias grbc="git rebase --continue"
alias grbi="git rebase -i"
alias grbm="git rebase $(git_main_branch)"
alias grbmi="git rebase $(git_main_branch) -i"
alias grbom="git rebase origin/$(git_main_branch)"
alias grbomi="git rebase origin/$(git_main_branch) -i"
alias grbs="git rebase --skip"

# Git reset aliases
alias grh="git reset"
alias grhh="git reset --hard"
alias groh="git reset origin/$(git_current_branch) --hard"
alias gru="git reset --"

# Git rm aliases
alias grm="git rm"
alias grmc="git rm --cached"

# Git show aliases
alias gsh="git show"

# Git stash aliases
alias gst="git status"
alias gsta="git stash push"
alias gstaa="git stash apply"
alias gstall="git stash --all"
alias gstc="git stash clear"
alias gstd="git stash drop"
alias gstl="git stash list"
alias gstp="git stash pop"
alias gsts="git stash show --text"
alias gstu="git stash --include-untracked"

# Delete a local branch
function gbdl() {
  branch_name="$(git symbolic-ref HEAD 2>/dev/null)" ||
  branch_name="(unnamed branch)"     # detached HEAD
  branch_name=${branch_name##refs/heads/}
    
  gcm
  gb -D "${branch_name}"
}

# Delete a remote branch
function gbdr() {
  branch_name="$(git symbolic-ref HEAD 2>/dev/null)" ||
  branch_name="(unnamed branch)"     # detached HEAD
  branch_name=${branch_name##refs/heads/}

  gcm
  gp origin --delete "${branch_name}"
}

# Delete a local and remote branch
function gbdrl() {
  branch_name="$(git symbolic-ref HEAD 2>/dev/null)" ||
  branch_name="(unnamed branch)"     # detached HEAD
  branch_name=${branch_name##refs/heads/}

  gcm
  gp origin --delete "${branch_name}"
  gb -D "${branch_name}"
}

# Second brain backup function
function brain-dump() {
  local original_dir=$(pwd)
  local backup_dir="$NOTES"
  local timestamp=$(date '+%Y-%m-%d %H-%M-%S')
  
  # Expand the path to handle escaped spaces properly
  backup_dir=$(eval echo "$backup_dir")
  
  # Check if we're in a git repository
  if [ ! -d "$backup_dir/.git" ]; then
    echo "Error: $backup_dir is not a git repository"
    return 1
  fi
  
  # Navigate to the second brain directory
  cd "$backup_dir" || {
    echo "Error: Cannot access $backup_dir"
    return 1
  }
  
  # Check if there are any changes to commit
  if git diff --quiet && git diff --cached --quiet; then
    echo "No changes to commit in second brain"
    cd "$original_dir"
    return 0
  fi
  
  # Add all changes
  git add .
  
  # Commit with timestamp
  git commit -m "$timestamp backup"
  
  # Push to remote if configured
  if git remote | grep -q .; then
    git push
    echo "Second brain backup completed and pushed to remote"
  else
    echo "Second brain backup completed (no remote configured)"
  fi
  
  # Return to original directory
  cd "$original_dir"
}

# Docker CLI completions
# ======================
# The following lines have been added by Docker Desktop to enable Docker CLI completions.
fpath=(/Users/maestro/.docker/completions $fpath)
# End of Docker CLI completions

# Terraform completions
# =====================
autoload -U +X bashcompinit && bashcompinit
complete -o nospace -C /opt/homebrew/bin/terraform terraform

# Starship prompt
# ===============
eval "$(starship init zsh)"

# === TMUX AUTO-ATTACH ===
# Start terminal in the same tmux session if not already in one
if command -v tmux &> /dev/null && [ -z "$TMUX" ]; then
    tmux attach-session -t workspace || tmux new-session -s workspace
fi

# === DOTFILES ZSH CONFIGURATION END - DO NOT EDIT MANUALLY ===
